{-

fromCompact gives a Compactable instance by supplying a functor instance for f and the compact function.

`separate` can be defined by mapping over `f (Either a b)` and `f (Either b a)`, using `hush` to convert to
an `Optional` and compact to convert to `f a` and `f b`, respectively.

-}
    let Either = ./../Either/Type

in  let Functor = ./../Functor/Type

in  let flipEither = ./../Either/flipEither

in  let hush = ./../Either/hush

in    λ(f : Type → Type)
    → λ(functor : Functor f)
    → λ(compact : ∀(a : Type) → f (Optional a) → f a)
    → { compact =
          compact
      , separate =
            λ(a : Type)
          → λ(b : Type)
          → λ(eithers : f (Either a b))
          → { _1 =
                compact
                a
                ( functor.map
                  (Either a b)
                  (Optional a)
                  (λ(either : Either a b) → hush b a (flipEither a b either))
                  eithers
                )
            , _2 =
                compact
                b
                (functor.map (Either a b) (Optional b) (hush a b) eithers)
            }
      }
