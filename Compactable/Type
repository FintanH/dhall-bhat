{-

Compactable serves as an abstraction over filtering and partitioning, using two functions
compact and separate, respectively.

Both functions work over some higher kind f (Type -> Type).

compact works over the f when it is fully applied with an Optional type. It filters out None
values, leaving only the values contained in the Some values.

separate works over the f when it is fully applied with an Either type. It partitions Left
values to the _1 element of a tuple, and Right values to the _2 element of a tuple.

Since both functions can be written in terms of the other, we can create instances by choosing one
of the function fromCompact or fromSeparate.

-}
    let Either = ./../Either/Type

in    λ(f : Type → Type)
    → { compact :
          ∀(a : Type) → f (Optional a) → f a
      , separate :
          ∀(a : Type) → ∀(b : Type) → f (Either a b) → { _1 : f a, _2 : f b }
      }
