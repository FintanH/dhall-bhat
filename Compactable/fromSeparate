{-
fromSeparate gives a Compactable instance by supplying a functor instance for f and the separate function.

`compact` can be defined by converting `Option a` into `Either a {}`, using `separate` and take the `_1`
element from the tuple.
-}
    let Either = ./../Either/Type

in  let Functor = ./../Functor/Type

in    λ(f : Type → Type)
    → λ(functor : Functor f)
    → λ ( separate
        : ∀(a : Type) → ∀(b : Type) → f (Either a b) → { _1 : f a, _2 : f b }
        )
    → { separate =
          separate
      , compact =
            λ(a : Type)
          → λ(optionals : f (Optional a))
          →     let E = constructors (Either a {})
            
            in  ( separate
                  a
                  {}
                  ( functor.map
                    (Optional a)
                    (Either a {})
                    (   λ(optional : Optional a)
                      → Optional/fold
                        a
                        optional
                        (Either a {})
                        E.Left
                        (E.Right {=})
                    )
                    optionals
                  )
                )._1
      }
