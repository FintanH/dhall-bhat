    let Monad = ../Monad/Type

in  let EitherT = ./Type

in  let Either = ../Either/Type

in  let EitherM = ../Either/Monad

in  let fold = ../Either/fold

in    λ(a : Type)
    → λ(m : Type → Type)
    → λ(monad : Monad m)
    → (   { applicative =
              ./Applicative  a m monad.applicative
          , monad =
              { bind =
                    λ(b : Type)
                  → λ(c : Type)
                  → λ(fa : EitherT a m b)
                  → λ(k : b → EitherT a m c)
                  → monad.monad.bind
                    (Either a b)
                    (Either a c)
                    fa
                    (   λ(either : Either a b)
                      → fold
                        a
                        b
                        (EitherT a m c)
                        (   λ(l : a)
                          → monad.applicative.applicative.pure
                            (Either a c)
                            < Left = l | Right : c >
                        )
                        (λ(r : b) → k r)
                        either
                    )
              }
          }
        : Monad (EitherT a m)
      )
