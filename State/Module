    let State = ./Type

in  let Module
        :   ∀(s : Type)
          → ∀(a : Type)
          → { embedState       : (s → { state : s, val : a }) → State s a
            , evalState        : State s a → s → a
            , execState        : State s a → s → s
            , get              : State s s
            , mapState         :
                  ∀(b : Type)
                → ({ state : s, val : a } → { state : s, val : b })
                → State s a
                → State s b
            , modify           : (s → s) → State s {}
            , put              : s → State s {}
            , runState         : State s a → s → { state : s, val : a }
            , Applicative :
                { applicative :
                    { ap   :
                          ∀(a : Type)
                        → ∀(b : Type)
                        → ∀(g : State s (a → b))
                        → ∀(fa : State s a)
                        → State s b
                    , pure : ∀(a : Type) → a → State s a
                    }
                , functor     :
                    { map :
                          ∀(a : Type)
                        → ∀(b : Type)
                        → ∀(g : a → b)
                        → ∀(fa : State s a)
                        → State s b
                    }
                }
            , Functor     :
                { map :
                      ∀(a : Type)
                    → ∀(b : Type)
                    → ∀(g : a → b)
                    → ∀(fa : State s a)
                    → State s b
                }
            , Monad       :
                { applicative :
                    { applicative :
                        { ap   :
                              ∀(a : Type)
                            → ∀(b : Type)
                            → ∀(g : State s (a → b))
                            → ∀(fa : State s a)
                            → State s b
                        , pure : ∀(a : Type) → a → State s a
                        }
                    , functor     :
                        { map :
                              ∀(a : Type)
                            → ∀(b : Type)
                            → ∀(g : a → b)
                            → ∀(fa : State s a)
                            → State s b
                        }
                    }
                , monad       :
                    { bind :
                          ∀(a : Type)
                        → ∀(b : Type)
                        → ∀(fa : State s a)
                        → ∀(k : a → State s b)
                        → State s b
                    }
                }
            , withState        : (s → s) → State s a → State s a
            }
        =   λ(s : Type)
          → λ(a : Type)
          → { embedState       = ./embedState  s a
            , evalState        = ./evalState  s a
            , execState        = ./execState  s a
            , get              = ./get  s
            , mapState         = ./mapState  s a
            , modify           = ./modify  s
            , put              = ./put  s
            , runState         =
                λ(state : State s a) → λ(new : s) → state.runState new
            , Applicative = ./Applicative  s
            , Functor     = ./Functor  s
            , Monad       = ./Monad  s
            , withState        = ./withState  s a
            }

in  Module
